# 被隐藏了的过程

linux下我们编译程序只需要

```
gcc hello.c
./a.out
```

实际上我们可以分为四个步骤：

1. 预处理
2. 编译
3. 汇编
4. 链接

## 预编译

首先是将hello.c和相关头文件，比如stdio.h 预编译成一个.i文件

```
gcc -E hello.c -o hello.i
```

做的事情主要是处理以 # 开头的预编译指令

- 删除所有#define，展开所有的宏定义
- 处理所有预编译指令，如 #if， #ifdef
- 处理#include
- 删除所有注释
- 添加行号和文件名标识，以便调试能够显示行号
- 保留所有的#pragma

## 编译

编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生产想要的汇编代码文件

```
gcc -S hello.i -o hello.s
```

## 汇编

将汇编代码转变成机器可以执行的指令

根据汇编指令和机器指令对照一一翻译

```
gcc -c hello.s -o hello.o
```

## 链接

将一大堆文件链接起来，最终输出可执行文件

# 编译器做了什么

编译器就是将高级语言翻译成机器语言的一个工具

编译可以分为6步：扫描，语法分析，语义分析，源代码优化，代码生成和目标代码优化

## 词法分析

使用一种类似 有限状态机的算法，来分割成一系列记号

分为 关键字，标识符，字面量，特殊符号

## 语法分析

对生成的记号进行语法分析，产生语法树。

可以确定 运算符号的优先级以及含义

## 语义分析

语法分析，只是从语法上进行判断，并不代表这个语句是真实有意义的

比如两个指针相乘，语法上成立，语义上就不成立



编译器分析的是 **静态语义**，即编译期确定的，而 **动态语义** 则是在运行时确定

静态语义分析会是指，将1个float赋值给1个int类型，这是不匹配的

动态语义分析会是指，你表达式做除法，结果你除了个0，则是在运行的时候才会发现的错误



分析完后，语法树会被标上类型

## 中间语言生成

编译器有很多层次优化

比如(2+6)，这个表达式的值是已经确定的，所以是完全可以在语法树上优化掉

直接在语法树上优化会比较困难，我们会 **转化成中间代码**，常见的类型有 三地址码，P代码

三地址码示例

```
x = y op z
```

表示y和z做了一个运算，赋值给x

## 目标代码生成与优化

编译器后端主要包括 **代码生成器**， **目标代码优化器**

代码生成器是将 **中间代码转换成目标机器代码**

不同的目标机器会对应生成不同的机器代码



目标代码优化器对机器代码进行优化，比如把乘法优化成移位操作，选择合适的寻址方式等等



经过这些，我们的变量实际上是还没有赋予地址的，更大的程序比如引入了外部代码，我们也不能确定。

因此需要通过链接器，来将这些文件链接到一起



# 链接器年龄比编译器长

在很久以前，我们用纸带来写程序，0和1 通过打孔和未打孔表示

后来我们使用汇编，通过符号来对操作进行更高程度的表示，比如 jmp 跳转，减少了繁琐的工作



在现代，软件规模都比较大，往往数百行代码。我们需要进行模块化划分，当程序划分成多个模块时，我们需要通过链接，来进行模块的拼接



# 模块拼接 —— 静态链接

从原理上，链接的工作是把一些指令对其他符号的引用加以修正

包括了 **地址和空间分配**，**符号决议**， **重定位**



过程：

- 源代码文件 .c 经过编译得到了目标文件 .o
- 目标文件和库一起链接形成最终可执行文件



比如我们一个main函数，调用了另外模块的foo函数

- 由于各个块单独编译，所以在main里面，是不知道foo函数的地址
- 因此，在编译过程中，遇到调用foo函数的，先暂时搁置
- 最后通过链接器，去修正